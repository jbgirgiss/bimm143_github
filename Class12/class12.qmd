---
title: "Class 12: RNASeq Analysis"
author: "Joseph Girgiss (PID: A17388247)"
format: pdf
toc: TRUE
---

## Background
Today we will analyze some RNASeq data from Himes et al. on the effects of a common steroid (Dexamethasone) on airway smooth muscle cells (ASM cells). 

Our starting point is the "counts" data and "metadata" that contain the count values for each gene in their different experiments (i.e. cell lines with or without the drug). 

## Data import

```{r}
# Complete the missing code
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <- read.csv("airway_metadata.csv")
```

Let's have a peek at these objects: 
```{r}
head(counts)
head(metadata)
```

> Q1.How many genes are in this dataset? 

```{r}
nrow(counts)
```
> Q. How many different experiments (columns in counts or rows in metadata) are there? 

```{r}
ncol(counts)
nrow(metadata)
```

> Q2. How many ‘control’ cell lines do we have? 

```{r}
table(metadata$dex == "control")
```
There are 4 control cell lines. 


## Toy differential gene expression

To start our analysis let's calculate the mean counts for all genes in the "control" experiments. 

Step 1: Extract all "control" columns from the `counts` object. 
Step 2: Calculate the mean for all rows (i.e. genes) of these "control" columns. 
Steps 3-4: Do the same for "treated"
Step 5: Compare there `control.mean` and `treated.mean` values. 

```{r}
control.inds <- metadata$dex == "control"
control.counts <- counts[ , control.inds]
control.mean <- rowMeans(control.counts)
head(control.mean)
```
>Q3. How would you make the above code in either approach more robust? Is there a function that could help here?

Use `rowMeans()` instead of `rowSums(control.counts) / ncol(control.counts)`

>Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

```{r}
treated.inds <- metadata$dex == "treated"
treated.counts <- counts[ , treated.inds]
treated.mean <- rowMeans(treated.counts)
head(treated.mean)
```


```{r}
meancounts <- data.frame(control.mean, treated.mean)
colSums(meancounts)
```

> Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples. Your plot should look something like the following.

```{r}
plot(meancounts)
```

> Q5 (b).You could also use the ggplot2 package to make this figure producing the plot below. What geom_?() function would you use for this plot?

We can ggplot and geom_point to generate the plot. 

```{r}
library(ggplot2)
ggplot(meancounts,aes(control.mean, treated.mean)) + 
  geom_point(alpha = 0.3) + 
  theme_bw()
```

> Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this? 

We can use `log` to do this. 

```{r}
plot(meancounts, log="xy")
```

We often talk metrics like "log2 fold change"

```{r}
# treated/control
log2(10/10)
log2(10/20)
log2(20/10)
log2(10/40)
log2(40/10)
```


Let's calculate the log2 change for our treated over control mean counts. 
```{r}
meancounts$log2fc <- log2(meancounts$treated.mean / meancounts$control.mean)
head(meancounts)
```

A common "rule of thumb" is a log2 fold change cutoff of +2 (upregulated genes) and -2 (downregulated genes). 

Number of upregulated genes: 
Number of downregulated genes: 
```{r}
sum(meancounts$log2fc >= +2, na.rm=T)
sum(meancounts$log2fc <= -2, na.rm=T)
```
```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```

> Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?

The purpose of the arr.ind argument will tell us which genes (rows) and samples (columns) have zero counts. We are going to ignore any genes that have zero counts in any sample so we just focus on the row answer. That way we can avoid issues with weird answers like -inf and NaN. 

> Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level?
> Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level?

```{r}
up.ind <- mycounts$log2fc > 2
sum(up.ind)
down.ind <- mycounts$log2fc < (-2)
sum(down.ind)
```
> Q10. Do you trust these results? Why or why not?

While this provides some interesting information, a key limitation is we do not actually know how  significant are the differences (missing p-values and other statisitcal analysis) between the means of the control and treated groups.Means are not a robust measure of center, and are susceptible to outliers. This can lead us to make incorrect conclusions.Fold change can be large (e.g. >>two-fold up- or down-regulation) without being statistically significant (e.g. based on p-values). 

```{r, message = FALSE}
library(DESeq2)

```

For DESeq analysis we need three things: 
 - count values (`countData`)
 - metadata telling us about the columns in `countData` (`colData`)
 - design of the experiment (i.e. what do you want to compare) 
 
Our first function from DEseq2 will setup the input required for analysis by storing all these 3 things together. 

```{r}
dds <- DESeqDataSetFromMatrix(countData = counts, 
                              colData = metadata, 
                              design = ~dex)
```

The main function in DESeq2 that runs the analysis is called `DESeq()`

```{r}
dds <- DESeq(dds)
```

```{r}
res <- results(dds)
head(res)
```

padj values are stricter to help establish which genes we should consider. 

## Volcano Plot

This is a common summary result figure from these types of experiments and plot the log2 fold-change vs the adjusted p-value. 

```{r}
plot(res$log2FoldChange, -log(res$padj),xlab="Log2(FoldChange)",
      ylab="-Log(P-value)")

abline(v=c(-2,2), col="red", lty=2)
abline(h=-log(0.04), col="red", lty=2)

# Setup our custom point color vector 
mycols <- rep("gray", nrow(res))
mycols[ abs(res$log2FoldChange) > 2 ]  <- "red" 

inds <- (res$padj < 0.01) & (abs(res$log2FoldChange) > 2 )
mycols[ inds ] <- "blue"

# Volcano plot with custom colors 
plot( res$log2FoldChange,  -log(res$padj), 
 col=mycols, ylab="-Log(P-value)", xlab="Log2(FoldChange)" )

# Cut-off lines
abline(v=c(-2,2), col="gray", lty=2)
abline(h=-log(0.1), col="gray", lty=2)
```


## Save our results

```{r}
write.csv(res, file="my_results.csv")
```


## Add gene annotation

To help make sense of the results and communicate them to other people we need to add some more annotations to our main `res` object. 

We will use two bioconductor packages to first map IDs to different formats, including the classic gene "symbol" gene name. 

Install the following in the console. 
`BiocManager::install("AnnotationDbi")`
`BiocManager::install("org.Hs.eg.db")`

```{r}
library(AnnotationDbi)
library(org.Hs.eg.db)
```

Let's see what is in `org.Hs.eg.db` with the `columns()` function: 

```{r}
columns(org.Hs.eg.db)
```
We can translate or "map" IDs between any of these 26 databases using the `mapIds()` function. 

```{r}
res$symbol <- mapIds(keys = row.names(res), # our current Ids
       keytype = "ENSEMBL" ,  # the format of our Ids
       x = org.Hs.eg.db,      # where to get the mappings from 
       column = "SYMBOL"      # the format/DB to map to 
      )

head(res)
```

Add mappings for "GENENAME" and "ENTREZID" and store as `res$genename` and `res$entrez`


```{r}
res$genename <- mapIds(keys = row.names(res), # our current Ids
       keytype = "ENSEMBL" ,  # the format of our Ids
       x = org.Hs.eg.db,      # where to get the mappings from 
       column = "GENENAME"    # the format/DB to map to 
      )

res$entrez <- mapIds(keys = row.names(res), # our current Ids
       keytype = "ENSEMBL" ,  # the format of our Ids
       x = org.Hs.eg.db,      # where to get the mappings from 
       column = "ENTREZID"    # the format/DB to map to 
      )

head(res)
```

## Pathway analysis 

There are lots of bioconductor packages to do this type analysis. For now, let's try one called **gage** again we need to install this if we don't have it already. 

```{r, message = FALSE}
library(gage)
library(gageData)
library(pathview)
```

To use **gage** I need two things: 

- a named vector of fold-change values for our DEGs (our geneset of interest)
- a set of pathways or genesets to use for annotation. 


```{r}
foldchanges <- res$log2FoldChange
names(foldchanges) <- res$entrez
head(foldchanges)
```

```{r}
data(kegg.sets.hs)

keggres = gage(foldchanges, gsets=kegg.sets.hs)
```

In our results object we have: 
```{r}
attributes(keggres)
```
```{r}
head(keggres$less, 5)
```

Let's look at one of these pathways with our genes colored up so we can see the overlap

```{r, message = FALSE}
pathview(pathway.id = "hsa05310", gene.data = foldchanges)
pathview(gene.data=foldchanges, pathway.id="hsa05310")
```

Add this pathway figure to our lap report

![](hsa05310.pathview.png)

## Save our main results
```{r}
write.csv(res, file="myresults_annotated.csv")
```






